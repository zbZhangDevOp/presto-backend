let fs,jwt,AsyncLock,InputError,AccessError;_5be‍.x([["save",()=>save],["reset",()=>reset],["userLock",()=>userLock],["getEmailFromAuthorization",()=>getEmailFromAuthorization],["login",()=>login],["logout",()=>logout],["register",()=>register],["getStore",()=>getStore],["setStore",()=>setStore]]);_5be‍.w("fs",[["default",["fs"],function(v){fs=v}]]);_5be‍.w("jsonwebtoken",[["default",["jwt"],function(v){jwt=v}]]);_5be‍.w("async-lock",[["default",["AsyncLock"],function(v){AsyncLock=v}]]);_5be‍.w("./error",[["InputError",["InputError"],function(v){InputError=v}],["AccessError",["AccessError"],function(v){AccessError=v}]]);




const lock = new AsyncLock();

const JWT_SECRET = 'llamallamaduck';
const DATABASE_FILE = './database.json';

/***************************************************************
                       State Management
***************************************************************/

let admins = {};

const sessionTimeouts = {};

const update = (admins) =>
  new Promise((resolve, reject) => {
    lock.acquire('saveData', () => {
      try {
        fs.writeFileSync(DATABASE_FILE, JSON.stringify({
          admins,
        }, null, 2));
        resolve();
      } catch {
        reject(new Error('Writing to database failed'));
      }
    });
  });

       const save = () => update(admins);
       const reset = () => {
  update({});
  admins = {};
};

try {
  const data = JSON.parse(fs.readFileSync(DATABASE_FILE));
  admins = data.admins;
} catch {
  console.log('WARNING: No database found, create a new one');
  save();
}

/***************************************************************
                       Helper Functions
***************************************************************/

       const userLock = callback => new Promise((resolve, reject) => {
  lock.acquire('userAuthLock', callback(resolve, reject));
});

/***************************************************************
                       Auth Functions
***************************************************************/

       const getEmailFromAuthorization = authorization => {
  try {
    const token = authorization.replace('Bearer ', '');
    const { email, } = jwt.verify(token, JWT_SECRET);
    if (!(email in admins)) {
      throw new AccessError('Invalid Token');
    }
    return email;
  } catch {
    throw new AccessError('Invalid token');
  }
};

       const login = (email, password) => userLock((resolve, reject) => {
  if (email in admins) {
    if (admins[email].password === password) {
      resolve(jwt.sign({ email, }, JWT_SECRET, { algorithm: 'HS256', }));
    }
  }
  reject(new InputError('Invalid username or password'));
});

       const logout = (email) => userLock((resolve, reject) => {
  admins[email].sessionActive = false;
  resolve();
});

       const register = (email, password, name) => userLock((resolve, reject) => {
  if (email in admins) {
    return reject(new InputError('Email address already registered'));
  }
  admins[email] = {
    name,
    password,
    store: {},
  };
  const token = jwt.sign({ email, }, JWT_SECRET, { algorithm: 'HS256', });
  resolve(token);
});

/***************************************************************
                       Store Functions
***************************************************************/

       const getStore = (email) => userLock((resolve, reject) => {
  resolve(admins[email].store);
});

       const setStore = (email, store) => userLock((resolve, reject) => {
  admins[email].store = store;
  resolve();
});